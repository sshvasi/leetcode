/**
 * Числа складываются, начиная с младших разрядов, и
 * поэтому нам удобно, что цифры в переданных списках располагаются в обратном порядке.
 * Благодаря этому, мы можем начать сложение с начала обоих списков.
 *
 * При сложении, нам нужно учитывать так называемый «перенос» —
 * ситуацию, при которой результат сложения однозначных чисел превосходит диапазон значений.
 * Для этого используем отдельную переменную, которую создаём вне цикла,
 * чтобы иметь к ней доступ на следующей итерации и брать предыдущее перенесённое значение.
 *
 * В самом цикле берём очередные значения из каждого списка. Складываем их.
 * Результат записываем в новый узел, перенесённое значение присваиваем переменной.
 * Далее переходим на следующий узел нового списка и на следующие узлы переданных списков.
 *
 * Числа могут иметь различное количество цифр, и условие цикла может выполниться
 * за счёт любого из узлов или из-за перенесённого значения, поэтому внутри цикла проверяем,
 * не равен ли очередной узел `null`. Если равен, тогда предполагаем, что его значение равно `0`.
 *
 * Особо стоить отметить, что используется узел-заглушка для того,
 * чтобы не создавать отдельно узел для первой цифры.
 *
 * - Сложность по времени — `O(max(m, n))`. Количество итераций равно максимальному числу цифр.
 * - Сложность по памяти — `O(max(m, n))`. В худшем случае количество цифр будет равно
 * и при сложении добавится одна дополнительная из-за переноса.
 */
const addTwoNumbers = (l1, l2) => {
  const sentinel = new ListNode(0);

  let tail = sentinel;
  let carry = 0;

  while (l1 !== null || l2 !== null || carry !== 0) {
    // Вычисляем число вместе с перенесённым значением.
    const x = (l1 !== null) ? l1.val : 0;
    const y = (l2 !== null) ? l2.val : 0;
    const sum = x + y + carry;

    // Отделяем число от перенесённого значения и создаём новый узел.
    const val = sum % 10;
    carry = Math.floor(sum / 10);
    tail.next = new ListNode(val);

    // Переходим на следующие узлы.
    tail = tail.next;
    l1 = (l1 !== null) ? l1.next : null;
    l2 = (l2 !== null) ? l2.next : null;
  }

  return sentinel.next;
};

/**
 * Диапазон для бин. поиска —
 * от начала массива до N – K, так как ищем самое левое число.
 * Затем при помощи цикла перебираем K чисел для создания массива.
 * Доп. память не требуется.
 *
 * Time: O(log(N - K) + K) | Space: O(1)
 */
function findClosestElements(arr, k, x) {
  const n = arr.length

  // Ищем левый индекс для отрезка.
  // Он не может располагаться дальше,
  // чем n - k, потому что в этом случае
  // мы не сможем получить отрезок длины k.
  let left = 0
  let right = n - k

  // Числа на index и index + k не могут одновременно оба быть в отрезке,
  // так как длина отрезка равна ровно k.
  // Даже, если мы находимся на самом левом числе в отрезке,
  // то прибавление к индексу k всё равно перенесёт нас за пределы отрезка.
  const isOnRight = (index) => {
    // Если число на index дальше от x, чем число на index + k,
    // значит начало искомого отрезка находится правее,
    // и мы должны сдвинуть левый указатель.
    return x - arr[index] > arr[index + k] - x
  }

  // Двигаем указатели, пока между ними не останется чисел.
  while (right - left > 0) {
    /* O(log(N – K) */
    const middle = left + Math.floor((right - left) / 2)

    if (isOnRight(middle)) {
      left = middle + 1
    } else {
      right = middle
    }
  }

  /* O(K) */
  return arr.slice(left, left + k)
}
